# BG-WebMacOS åº”ç”¨ç”Ÿæ€ç³»ç»Ÿæ¶æ„è®¾è®¡

## ğŸ“‹ ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æ•´ä½“æ¶æ„](#æ•´ä½“æ¶æ„)
3. [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
4. [åº”ç”¨éš”ç¦»æœºåˆ¶](#åº”ç”¨éš”ç¦»æœºåˆ¶)
5. [æƒé™ç®¡ç†ç³»ç»Ÿ](#æƒé™ç®¡ç†ç³»ç»Ÿ)
6. [åº”ç”¨ç”Ÿå‘½å‘¨æœŸ](#åº”ç”¨ç”Ÿå‘½å‘¨æœŸ)
7. [æ•°æ®å­˜å‚¨æ¶æ„](#æ•°æ®å­˜å‚¨æ¶æ„)
8. [é€šä¿¡æœºåˆ¶](#é€šä¿¡æœºåˆ¶)
9. [åº”ç”¨å•†åº—æ¶æ„](#åº”ç”¨å•†åº—æ¶æ„)
10. [å®‰å…¨æ¶æ„](#å®‰å…¨æ¶æ„)
11. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
12. [æ‰©å±•æ€§è®¾è®¡](#æ‰©å±•æ€§è®¾è®¡)

## ğŸ¯ æ¦‚è¿°

### è®¾è®¡ç›®æ ‡

BG-WebMacOS åº”ç”¨ç”Ÿæ€ç³»ç»Ÿæ—¨åœ¨åˆ›å»ºä¸€ä¸ªå®‰å…¨ã€é«˜æ•ˆã€å¯æ‰©å±•çš„ Web æ¡Œé¢ç¯å¢ƒï¼Œæ”¯æŒç¬¬ä¸‰æ–¹åº”ç”¨çš„å¼€å‘ã€åˆ†å‘å’Œè¿è¡Œã€‚æ ¸å¿ƒè®¾è®¡ç›®æ ‡åŒ…æ‹¬ï¼š

- **æ¡†æ¶ä¸åº”ç”¨éš”ç¦»**ï¼šç¡®ä¿ç³»ç»Ÿæ¡†æ¶ä¸ç¬¬ä¸‰æ–¹åº”ç”¨å®Œå…¨éš”ç¦»
- **å®‰å…¨æ²™ç®±**ï¼šæ¯ä¸ªåº”ç”¨è¿è¡Œåœ¨ç‹¬ç«‹çš„å®‰å…¨æ²™ç®±ä¸­
- **æƒé™æ§åˆ¶**ï¼šç»†ç²’åº¦çš„æƒé™ç®¡ç†å’Œè®¿é—®æ§åˆ¶
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šå®Œæ•´çš„åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†æœºåˆ¶
- **é«˜æ€§èƒ½**ï¼šä¼˜åŒ–çš„èµ„æºç®¡ç†å’Œæ¸²æŸ“æ€§èƒ½
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒæ’ä»¶åŒ–å’Œæ¨¡å—åŒ–æ‰©å±•

### æ ¸å¿ƒåŸåˆ™

1. **å®‰å…¨ç¬¬ä¸€**ï¼šæ‰€æœ‰è®¾è®¡å†³ç­–éƒ½ä»¥å®‰å…¨ä¸ºé¦–è¦è€ƒè™‘
2. **éš”ç¦»ä¼˜å…ˆ**ï¼šåº”ç”¨é—´ã€åº”ç”¨ä¸ç³»ç»Ÿé—´ä¸¥æ ¼éš”ç¦»
3. **æ€§èƒ½å¯¼å‘**ï¼šä¼˜åŒ–ç”¨æˆ·ä½“éªŒå’Œç³»ç»Ÿæ€§èƒ½
4. **å¼€å‘å‹å¥½**ï¼šæä¾›ç®€æ´æ˜“ç”¨çš„å¼€å‘æ¥å£
5. **æ ‡å‡†å…¼å®¹**ï¼šéµå¾ª Web æ ‡å‡†å’Œæœ€ä½³å®è·µ

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç¬¬ä¸‰æ–¹åº”ç”¨å±‚ (Apps Layer)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   åº”ç”¨è¿è¡Œæ—¶å±‚ (Runtime Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   åº”ç”¨ç®¡ç†å±‚ (Management Layer)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç³»ç»ŸæœåŠ¡å±‚ (Services Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ ¸å¿ƒæ¡†æ¶å±‚ (Framework Layer)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æµè§ˆå™¨å±‚ (Browser Layer)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¶æ„ç»„ä»¶å›¾

```mermaid
graph TB
    subgraph "Browser Environment"
        Browser["æµè§ˆå™¨å¼•æ“"]
        DOM["DOM API"]
        WebAPI["Web APIs"]
    end
    
    subgraph "BG-WebMacOS Framework"
        Core["æ ¸å¿ƒæ¡†æ¶"]
        WindowManager["çª—å£ç®¡ç†å™¨"]
        EventBus["äº‹ä»¶æ€»çº¿"]
        Router["è·¯ç”±ç®¡ç†"]
        StateManager["çŠ¶æ€ç®¡ç†"]
    end
    
    subgraph "System Services"
        AppManager["åº”ç”¨ç®¡ç†å™¨"]
        PermissionManager["æƒé™ç®¡ç†å™¨"]
        StorageManager["å­˜å‚¨ç®¡ç†å™¨"]
        SecurityManager["å®‰å…¨ç®¡ç†å™¨"]
        NotificationManager["é€šçŸ¥ç®¡ç†å™¨"]
    end
    
    subgraph "App Runtime"
        Sandbox["æ²™ç®±ç¯å¢ƒ"]
        AppSDK["åº”ç”¨ SDK"]
        LifecycleManager["ç”Ÿå‘½å‘¨æœŸç®¡ç†"]
        ResourceManager["èµ„æºç®¡ç†"]
    end
    
    subgraph "App Store"
        StoreService["å•†åº—æœåŠ¡"]
        PackageManager["åŒ…ç®¡ç†å™¨"]
        UpdateManager["æ›´æ–°ç®¡ç†å™¨"]
        ReviewSystem["å®¡æ ¸ç³»ç»Ÿ"]
    end
    
    subgraph "Third-party Apps"
        App1["åº”ç”¨ A"]
        App2["åº”ç”¨ B"]
        App3["åº”ç”¨ C"]
    end
    
    Browser --> Core
    Core --> WindowManager
    Core --> EventBus
    Core --> Router
    Core --> StateManager
    
    Core --> AppManager
    Core --> PermissionManager
    Core --> StorageManager
    Core --> SecurityManager
    Core --> NotificationManager
    
    AppManager --> Sandbox
    AppManager --> AppSDK
    AppManager --> LifecycleManager
    AppManager --> ResourceManager
    
    AppManager --> StoreService
    StoreService --> PackageManager
    StoreService --> UpdateManager
    StoreService --> ReviewSystem
    
    Sandbox --> App1
    Sandbox --> App2
    Sandbox --> App3
```

## ğŸ§© æ ¸å¿ƒç»„ä»¶

### 1. åº”ç”¨ç®¡ç†å™¨ (AppManager)

```typescript
class AppManager {
  private apps: Map<string, AppInstance> = new Map()
  private registry: AppRegistry
  private sandboxManager: SandboxManager
  private lifecycleManager: LifecycleManager
  
  async installApp(packagePath: string): Promise<AppInfo> {
    // 1. éªŒè¯åº”ç”¨åŒ…
    const manifest = await this.validatePackage(packagePath)
    
    // 2. æ£€æŸ¥æƒé™
    await this.checkPermissions(manifest.permissions)
    
    // 3. åˆ›å»ºåº”ç”¨å®ä¾‹
    const appInstance = await this.createAppInstance(manifest)
    
    // 4. æ³¨å†Œåº”ç”¨
    await this.registry.register(appInstance)
    
    // 5. æ‰§è¡Œå®‰è£…è„šæœ¬
    await this.lifecycleManager.runInstallScript(appInstance)
    
    return appInstance.info
  }
  
  async launchApp(appId: string, args?: any): Promise<AppInstance> {
    const appInfo = await this.registry.getApp(appId)
    if (!appInfo) {
      throw new Error(`App not found: ${appId}`)
    }
    
    // åˆ›å»ºæ²™ç®±ç¯å¢ƒ
    const sandbox = await this.sandboxManager.createSandbox(appInfo)
    
    // åŠ è½½åº”ç”¨
    const appInstance = await this.loadApp(appInfo, sandbox, args)
    
    // å¯åŠ¨åº”ç”¨
    await this.lifecycleManager.startApp(appInstance)
    
    this.apps.set(appId, appInstance)
    return appInstance
  }
  
  async terminateApp(appId: string): Promise<void> {
    const appInstance = this.apps.get(appId)
    if (!appInstance) return
    
    // æ‰§è¡Œæ¸…ç†é€»è¾‘
    await this.lifecycleManager.stopApp(appInstance)
    
    // é”€æ¯æ²™ç®±
    await this.sandboxManager.destroySandbox(appInstance.sandbox)
    
    this.apps.delete(appId)
  }
  
  async uninstallApp(appId: string): Promise<void> {
    // 1. åœæ­¢åº”ç”¨ï¼ˆå¦‚æœæ­£åœ¨è¿è¡Œï¼‰
    if (this.apps.has(appId)) {
      await this.terminateApp(appId)
    }
    
    // 2. æ‰§è¡Œå¸è½½è„šæœ¬
    const appInfo = await this.registry.getApp(appId)
    await this.lifecycleManager.runUninstallScript(appInfo)
    
    // 3. æ¸…ç†åº”ç”¨æ•°æ®
    await this.cleanupAppData(appId)
    
    // 4. ä»æ³¨å†Œè¡¨ç§»é™¤
    await this.registry.unregister(appId)
  }
}
```

### 2. æ²™ç®±ç®¡ç†å™¨ (SandboxManager)

```typescript
class SandboxManager {
  async createSandbox(appInfo: AppInfo): Promise<Sandbox> {
    const sandbox = new Sandbox({
      appId: appInfo.id,
      permissions: appInfo.permissions,
      resources: appInfo.resources
    })
    
    // åˆ›å»ºéš”ç¦»çš„æ‰§è¡Œç¯å¢ƒ
    await sandbox.initialize()
    
    // æ³¨å…¥åº”ç”¨ SDK
    await this.injectSDK(sandbox, appInfo)
    
    // è®¾ç½®å®‰å…¨ç­–ç•¥
    await this.applySecurityPolicy(sandbox, appInfo)
    
    return sandbox
  }
  
  private async injectSDK(sandbox: Sandbox, appInfo: AppInfo): Promise<void> {
    const sdk = new AppSDK({
      appId: appInfo.id,
      permissions: appInfo.permissions,
      sandbox: sandbox
    })
    
    // å°† SDK æ³¨å…¥åˆ°æ²™ç®±ç¯å¢ƒ
    sandbox.global.useAppSDK = () => sdk
  }
  
  private async applySecurityPolicy(sandbox: Sandbox, appInfo: AppInfo): Promise<void> {
    // é™åˆ¶å…¨å±€å¯¹è±¡è®¿é—®
    sandbox.restrictGlobalAccess([
      'window.parent',
      'window.top',
      'document.domain',
      'localStorage', // ä½¿ç”¨å—æ§çš„å­˜å‚¨ API
      'sessionStorage'
    ])
    
    // é™åˆ¶ç½‘ç»œè®¿é—®
    if (!appInfo.permissions.includes('network')) {
      sandbox.blockNetworkAccess()
    }
    
    // é™åˆ¶æ–‡ä»¶ç³»ç»Ÿè®¿é—®
    if (!appInfo.permissions.includes('filesystem')) {
      sandbox.blockFileSystemAccess()
    }
  }
}
```

### 3. æƒé™ç®¡ç†å™¨ (PermissionManager)

```typescript
class PermissionManager {
  private permissions: Map<string, PermissionConfig> = new Map()
  private appPermissions: Map<string, Set<string>> = new Map()
  
  constructor() {
    this.initializePermissions()
  }
  
  private initializePermissions(): void {
    // å®šä¹‰ç³»ç»Ÿæƒé™
    this.permissions.set('storage', {
      name: 'storage',
      description: 'è®¿é—®æœ¬åœ°å­˜å‚¨',
      level: 'normal',
      autoGrant: true
    })
    
    this.permissions.set('clipboard', {
      name: 'clipboard',
      description: 'è®¿é—®å‰ªè´´æ¿',
      level: 'normal',
      autoGrant: false
    })
    
    this.permissions.set('filesystem', {
      name: 'filesystem',
      description: 'è®¿é—®æ–‡ä»¶ç³»ç»Ÿ',
      level: 'dangerous',
      autoGrant: false
    })
    
    this.permissions.set('network', {
      name: 'network',
      description: 'è®¿é—®ç½‘ç»œ',
      level: 'dangerous',
      autoGrant: false
    })
  }
  
  async requestPermissions(appId: string, permissions: string[]): Promise<PermissionResult> {
    const result: PermissionResult = {
      granted: [],
      denied: [],
      pending: []
    }
    
    for (const permission of permissions) {
      const config = this.permissions.get(permission)
      if (!config) {
        result.denied.push(permission)
        continue
      }
      
      if (config.autoGrant) {
        result.granted.push(permission)
        this.grantPermission(appId, permission)
      } else {
        // éœ€è¦ç”¨æˆ·ç¡®è®¤
        const userChoice = await this.requestUserPermission(appId, config)
        if (userChoice) {
          result.granted.push(permission)
          this.grantPermission(appId, permission)
        } else {
          result.denied.push(permission)
        }
      }
    }
    
    return result
  }
  
  checkPermission(appId: string, permission: string): boolean {
    const appPerms = this.appPermissions.get(appId)
    return appPerms?.has(permission) || false
  }
  
  private grantPermission(appId: string, permission: string): void {
    if (!this.appPermissions.has(appId)) {
      this.appPermissions.set(appId, new Set())
    }
    this.appPermissions.get(appId)!.add(permission)
  }
  
  private async requestUserPermission(appId: string, config: PermissionConfig): Promise<boolean> {
    return new Promise((resolve) => {
      // æ˜¾ç¤ºæƒé™è¯·æ±‚å¯¹è¯æ¡†
      const dialog = new PermissionDialog({
        appId,
        permission: config,
        onAllow: () => resolve(true),
        onDeny: () => resolve(false)
      })
      
      dialog.show()
    })
  }
}
```

### 4. å­˜å‚¨ç®¡ç†å™¨ (StorageManager)

```typescript
class StorageManager {
  private databases: Map<string, IDBDatabase> = new Map()
  private quotas: Map<string, StorageQuota> = new Map()
  
  async getAppStorage(appId: string): Promise<AppStorage> {
    // ä¸ºæ¯ä¸ªåº”ç”¨åˆ›å»ºç‹¬ç«‹çš„å­˜å‚¨ç©ºé—´
    const dbName = `app_${appId}`
    
    if (!this.databases.has(dbName)) {
      const db = await this.openDatabase(dbName)
      this.databases.set(dbName, db)
    }
    
    return new AppStorage({
      appId,
      database: this.databases.get(dbName)!,
      quota: this.quotas.get(appId) || this.getDefaultQuota()
    })
  }
  
  private async openDatabase(dbName: string): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1)
      
      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve(request.result)
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        
        // åˆ›å»ºåŸºç¡€å¯¹è±¡å­˜å‚¨
        if (!db.objectStoreNames.contains('keyvalue')) {
          db.createObjectStore('keyvalue', { keyPath: 'key' })
        }
        
        if (!db.objectStoreNames.contains('files')) {
          db.createObjectStore('files', { keyPath: 'path' })
        }
      }
    })
  }
  
  private getDefaultQuota(): StorageQuota {
    return {
      maxSize: 100 * 1024 * 1024, // 100MB
      maxFiles: 10000,
      maxDatabases: 5
    }
  }
}

class AppStorage {
  constructor(private config: AppStorageConfig) {}
  
  async setItem(key: string, value: any): Promise<void> {
    await this.checkQuota()
    
    const transaction = this.config.database.transaction(['keyvalue'], 'readwrite')
    const store = transaction.objectStore('keyvalue')
    
    await new Promise((resolve, reject) => {
      const request = store.put({
        key,
        value: JSON.stringify(value),
        timestamp: Date.now()
      })
      
      request.onsuccess = () => resolve(request.result)
      request.onerror = () => reject(request.error)
    })
  }
  
  async getItem(key: string): Promise<any> {
    const transaction = this.config.database.transaction(['keyvalue'], 'readonly')
    const store = transaction.objectStore('keyvalue')
    
    return new Promise((resolve, reject) => {
      const request = store.get(key)
      
      request.onsuccess = () => {
        const result = request.result
        resolve(result ? JSON.parse(result.value) : null)
      }
      
      request.onerror = () => reject(request.error)
    })
  }
  
  private async checkQuota(): Promise<void> {
    const usage = await this.getStorageUsage()
    if (usage.size > this.config.quota.maxSize) {
      throw new Error('Storage quota exceeded')
    }
  }
  
  private async getStorageUsage(): Promise<StorageUsage> {
    // è®¡ç®—å½“å‰å­˜å‚¨ä½¿ç”¨é‡
    const transaction = this.config.database.transaction(['keyvalue'], 'readonly')
    const store = transaction.objectStore('keyvalue')
    
    return new Promise((resolve, reject) => {
      const request = store.getAll()
      
      request.onsuccess = () => {
        const items = request.result
        const size = items.reduce((total, item) => {
          return total + JSON.stringify(item).length
        }, 0)
        
        resolve({
          size,
          itemCount: items.length
        })
      }
      
      request.onerror = () => reject(request.error)
    })
  }
}
```

## ğŸ”’ åº”ç”¨éš”ç¦»æœºåˆ¶

### 1. æ²™ç®±éš”ç¦»

```typescript
class Sandbox {
  private iframe: HTMLIFrameElement
  private context: SandboxContext
  private securityPolicy: SecurityPolicy
  
  constructor(config: SandboxConfig) {
    this.createIframe(config)
    this.setupSecurityPolicy(config)
  }
  
  private createIframe(config: SandboxConfig): void {
    this.iframe = document.createElement('iframe')
    
    // è®¾ç½®æ²™ç®±å±æ€§
    this.iframe.sandbox.add(
      'allow-scripts',
      'allow-same-origin',
      'allow-forms'
    )
    
    // æ ¹æ®æƒé™åŠ¨æ€æ·»åŠ æ²™ç®±æƒé™
    if (config.permissions.includes('popups')) {
      this.iframe.sandbox.add('allow-popups')
    }
    
    if (config.permissions.includes('modals')) {
      this.iframe.sandbox.add('allow-modals')
    }
    
    // è®¾ç½® CSP (Content Security Policy)
    this.iframe.setAttribute('csp', this.generateCSP(config))
    
    // éšè— iframe
    this.iframe.style.display = 'none'
    document.body.appendChild(this.iframe)
  }
  
  private generateCSP(config: SandboxConfig): string {
    const policies = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'"
    ]
    
    // æ ¹æ®æƒé™è°ƒæ•´ CSP
    if (config.permissions.includes('network')) {
      policies.push("connect-src 'self' https:")
    } else {
      policies.push("connect-src 'none'")
    }
    
    if (!config.permissions.includes('eval')) {
      policies.push("script-src 'self'")
    }
    
    return policies.join('; ')
  }
  
  async loadApp(appCode: string, appData: any): Promise<void> {
    const appDocument = this.iframe.contentDocument!
    
    // åˆ›å»ºåº”ç”¨å®¹å™¨
    const appContainer = appDocument.createElement('div')
    appContainer.id = 'app-root'
    appDocument.body.appendChild(appContainer)
    
    // æ³¨å…¥åº”ç”¨ä»£ç 
    const script = appDocument.createElement('script')
    script.textContent = this.wrapAppCode(appCode, appData)
    appDocument.head.appendChild(script)
  }
  
  private wrapAppCode(appCode: string, appData: any): string {
    return `
      (function() {
        'use strict';
        
        // é™åˆ¶å…¨å±€å¯¹è±¡è®¿é—®
        const restrictedGlobals = ['parent', 'top', 'opener'];
        restrictedGlobals.forEach(prop => {
          try {
            Object.defineProperty(window, prop, {
              get() { throw new Error('Access denied'); },
              set() { throw new Error('Access denied'); }
            });
          } catch (e) {}
        });
        
        // æ³¨å…¥åº”ç”¨æ•°æ®
        window.__APP_DATA__ = ${JSON.stringify(appData)};
        
        // æ‰§è¡Œåº”ç”¨ä»£ç 
        ${appCode}
      })();
    `
  }
}
```

### 2. å†…å­˜éš”ç¦»

```typescript
class MemoryManager {
  private appMemoryUsage: Map<string, MemoryUsage> = new Map()
  private memoryLimits: Map<string, MemoryLimit> = new Map()
  
  trackAppMemory(appId: string): void {
    const monitor = new MemoryMonitor(appId)
    
    monitor.on('usage-update', (usage: MemoryUsage) => {
      this.appMemoryUsage.set(appId, usage)
      this.checkMemoryLimit(appId, usage)
    })
    
    monitor.start()
  }
  
  private checkMemoryLimit(appId: string, usage: MemoryUsage): void {
    const limit = this.memoryLimits.get(appId) || this.getDefaultLimit()
    
    if (usage.heapUsed > limit.maxHeap) {
      this.handleMemoryExceeded(appId, 'heap', usage.heapUsed, limit.maxHeap)
    }
    
    if (usage.domNodes > limit.maxDOMNodes) {
      this.handleMemoryExceeded(appId, 'dom', usage.domNodes, limit.maxDOMNodes)
    }
  }
  
  private handleMemoryExceeded(appId: string, type: string, current: number, limit: number): void {
    console.warn(`App ${appId} exceeded ${type} memory limit: ${current}/${limit}`)
    
    // å‘é€è­¦å‘Šç»™åº”ç”¨
    this.sendMemoryWarning(appId, type, current, limit)
    
    // å¦‚æœè¶…å‡ºä¸¥é‡ï¼Œå¼ºåˆ¶åƒåœ¾å›æ”¶æˆ–ç»ˆæ­¢åº”ç”¨
    if (current > limit * 1.5) {
      this.forceGarbageCollection(appId)
    }
  }
}
```

### 3. ç½‘ç»œéš”ç¦»

```typescript
class NetworkManager {
  private allowedDomains: Map<string, string[]> = new Map()
  private requestInterceptor: RequestInterceptor
  
  constructor() {
    this.setupRequestInterceptor()
  }
  
  private setupRequestInterceptor(): void {
    this.requestInterceptor = new RequestInterceptor()
    
    this.requestInterceptor.intercept('fetch', (appId: string, url: string, options: any) => {
      return this.validateNetworkRequest(appId, url, options)
    })
    
    this.requestInterceptor.intercept('xhr', (appId: string, url: string, options: any) => {
      return this.validateNetworkRequest(appId, url, options)
    })
  }
  
  private async validateNetworkRequest(appId: string, url: string, options: any): Promise<boolean> {
    // æ£€æŸ¥åº”ç”¨æ˜¯å¦æœ‰ç½‘ç»œæƒé™
    if (!this.hasNetworkPermission(appId)) {
      throw new Error('Network access denied: missing permission')
    }
    
    // æ£€æŸ¥åŸŸåç™½åå•
    const allowedDomains = this.allowedDomains.get(appId)
    if (allowedDomains && !this.isDomainAllowed(url, allowedDomains)) {
      throw new Error(`Network access denied: domain not allowed - ${url}`)
    }
    
    // æ£€æŸ¥è¯·æ±‚ç±»å‹å’Œå†…å®¹
    if (this.isUnsafeRequest(options)) {
      throw new Error('Unsafe network request blocked')
    }
    
    return true
  }
  
  private isDomainAllowed(url: string, allowedDomains: string[]): boolean {
    try {
      const urlObj = new URL(url)
      return allowedDomains.some(domain => {
        return urlObj.hostname === domain || urlObj.hostname.endsWith(`.${domain}`)
      })
    } catch {
      return false
    }
  }
  
  private isUnsafeRequest(options: any): boolean {
    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ•æ„Ÿå¤´éƒ¨
    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key']
    if (options.headers) {
      for (const header of sensitiveHeaders) {
        if (header in options.headers) {
          return true
        }
      }
    }
    
    // æ£€æŸ¥è¯·æ±‚ä½“å¤§å°
    if (options.body && options.body.length > 10 * 1024 * 1024) { // 10MB
      return true
    }
    
    return false
  }
}
```

## ğŸ” æƒé™ç®¡ç†ç³»ç»Ÿ

### æƒé™åˆ†çº§

```typescript
enum PermissionLevel {
  NORMAL = 'normal',      // æ™®é€šæƒé™ï¼Œè‡ªåŠ¨æˆäºˆ
  SENSITIVE = 'sensitive', // æ•æ„Ÿæƒé™ï¼Œéœ€è¦ç”¨æˆ·ç¡®è®¤
  DANGEROUS = 'dangerous'  // å±é™©æƒé™ï¼Œéœ€è¦ç‰¹æ®Šå®¡æ ¸
}

interface PermissionDefinition {
  name: string
  level: PermissionLevel
  description: string
  category: string
  dependencies?: string[]
  conflicts?: string[]
  autoRevoke?: boolean
  timeLimit?: number
}

const SYSTEM_PERMISSIONS: Record<string, PermissionDefinition> = {
  'storage': {
    name: 'storage',
    level: PermissionLevel.NORMAL,
    description: 'è®¿é—®åº”ç”¨æœ¬åœ°å­˜å‚¨',
    category: 'data'
  },
  
  'clipboard': {
    name: 'clipboard',
    level: PermissionLevel.SENSITIVE,
    description: 'è¯»å†™ç³»ç»Ÿå‰ªè´´æ¿',
    category: 'system',
    autoRevoke: true,
    timeLimit: 300000 // 5åˆ†é’Ÿ
  },
  
  'filesystem': {
    name: 'filesystem',
    level: PermissionLevel.DANGEROUS,
    description: 'è®¿é—®æ–‡ä»¶ç³»ç»Ÿ',
    category: 'system',
    dependencies: ['storage']
  },
  
  'network': {
    name: 'network',
    level: PermissionLevel.DANGEROUS,
    description: 'è®¿é—®ç½‘ç»œèµ„æº',
    category: 'network'
  },
  
  'camera': {
    name: 'camera',
    level: PermissionLevel.DANGEROUS,
    description: 'è®¿é—®æ‘„åƒå¤´',
    category: 'media',
    conflicts: ['microphone']
  },
  
  'microphone': {
    name: 'microphone',
    level: PermissionLevel.DANGEROUS,
    description: 'è®¿é—®éº¦å…‹é£',
    category: 'media'
  },
  
  'notifications': {
    name: 'notifications',
    level: PermissionLevel.SENSITIVE,
    description: 'æ˜¾ç¤ºç³»ç»Ÿé€šçŸ¥',
    category: 'ui'
  },
  
  'fullscreen': {
    name: 'fullscreen',
    level: PermissionLevel.SENSITIVE,
    description: 'å…¨å±æ˜¾ç¤º',
    category: 'ui'
  },
  
  'geolocation': {
    name: 'geolocation',
    level: PermissionLevel.DANGEROUS,
    description: 'è·å–åœ°ç†ä½ç½®',
    category: 'privacy'
  }
}
```

### åŠ¨æ€æƒé™ç®¡ç†

```typescript
class DynamicPermissionManager {
  private runtimePermissions: Map<string, RuntimePermission> = new Map()
  private permissionHistory: Map<string, PermissionHistory[]> = new Map()
  
  async requestRuntimePermission(appId: string, permission: string, context?: any): Promise<boolean> {
    const permDef = SYSTEM_PERMISSIONS[permission]
    if (!permDef) {
      throw new Error(`Unknown permission: ${permission}`)
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰æƒé™
    const existing = this.runtimePermissions.get(`${appId}:${permission}`)
    if (existing && !this.isPermissionExpired(existing)) {
      return true
    }
    
    // æ£€æŸ¥æƒé™ä¾èµ–
    if (permDef.dependencies) {
      for (const dep of permDef.dependencies) {
        const hasDepPermission = await this.checkPermission(appId, dep)
        if (!hasDepPermission) {
          throw new Error(`Missing dependency permission: ${dep}`)
        }
      }
    }
    
    // æ£€æŸ¥æƒé™å†²çª
    if (permDef.conflicts) {
      for (const conflict of permDef.conflicts) {
        const hasConflictPermission = await this.checkPermission(appId, conflict)
        if (hasConflictPermission) {
          throw new Error(`Conflicting permission already granted: ${conflict}`)
        }
      }
    }
    
    // æ ¹æ®æƒé™çº§åˆ«å¤„ç†
    let granted = false
    switch (permDef.level) {
      case PermissionLevel.NORMAL:
        granted = true
        break
        
      case PermissionLevel.SENSITIVE:
        granted = await this.requestUserConsent(appId, permDef, context)
        break
        
      case PermissionLevel.DANGEROUS:
        granted = await this.requestSpecialApproval(appId, permDef, context)
        break
    }
    
    if (granted) {
      this.grantRuntimePermission(appId, permission, permDef)
      this.recordPermissionHistory(appId, permission, 'granted', context)
    } else {
      this.recordPermissionHistory(appId, permission, 'denied', context)
    }
    
    return granted
  }
  
  private grantRuntimePermission(appId: string, permission: string, permDef: PermissionDefinition): void {
    const runtimePerm: RuntimePermission = {
      appId,
      permission,
      grantedAt: Date.now(),
      expiresAt: permDef.timeLimit ? Date.now() + permDef.timeLimit : null,
      autoRevoke: permDef.autoRevoke || false
    }
    
    this.runtimePermissions.set(`${appId}:${permission}`, runtimePerm)
    
    // è®¾ç½®è‡ªåŠ¨æ’¤é”€å®šæ—¶å™¨
    if (runtimePerm.expiresAt) {
      setTimeout(() => {
        this.revokePermission(appId, permission)
      }, permDef.timeLimit!)
    }
  }
  
  private async requestUserConsent(appId: string, permDef: PermissionDefinition, context?: any): Promise<boolean> {
    return new Promise((resolve) => {
      const dialog = new PermissionDialog({
        appId,
        permission: permDef,
        context,
        onApprove: () => resolve(true),
        onDeny: () => resolve(false),
        onRemember: (choice: boolean) => {
          // è®°ä½ç”¨æˆ·é€‰æ‹©
          this.saveUserPreference(appId, permDef.name, choice)
          resolve(choice)
        }
      })
      
      dialog.show()
    })
  }
  
  private async requestSpecialApproval(appId: string, permDef: PermissionDefinition, context?: any): Promise<boolean> {
    // å±é™©æƒé™éœ€è¦é¢å¤–éªŒè¯
    const appInfo = await AppRegistry.getApp(appId)
    
    // æ£€æŸ¥åº”ç”¨æ¥æº
    if (!this.isTrustedSource(appInfo.source)) {
      return false
    }
    
    // æ£€æŸ¥åº”ç”¨ç­¾å
    if (!await this.verifyAppSignature(appInfo)) {
      return false
    }
    
    // æ£€æŸ¥ç”¨æˆ·å†å²è¡Œä¸º
    const history = this.permissionHistory.get(appId) || []
    const recentDenials = history.filter(h => 
      h.permission === permDef.name && 
      h.action === 'denied' && 
      Date.now() - h.timestamp < 24 * 60 * 60 * 1000 // 24å°æ—¶å†…
    )
    
    if (recentDenials.length >= 3) {
      return false // 24å°æ—¶å†…æ‹’ç»3æ¬¡ä»¥ä¸Šï¼Œè‡ªåŠ¨æ‹’ç»
    }
    
    return this.requestUserConsent(appId, permDef, context)
  }
}
```

## ğŸ”„ åº”ç”¨ç”Ÿå‘½å‘¨æœŸ

### ç”Ÿå‘½å‘¨æœŸçŠ¶æ€

```typescript
enum AppState {
  INSTALLING = 'installing',
  INSTALLED = 'installed',
  STARTING = 'starting',
  RUNNING = 'running',
  PAUSED = 'paused',
  STOPPING = 'stopping',
  STOPPED = 'stopped',
  UPDATING = 'updating',
  UNINSTALLING = 'uninstalling',
  ERROR = 'error'
}

interface AppLifecycleEvent {
  appId: string
  state: AppState
  previousState: AppState
  timestamp: number
  data?: any
}

class AppLifecycleManager {
  private appStates: Map<string, AppState> = new Map()
  private lifecycleHooks: Map<string, LifecycleHook[]> = new Map()
  private eventBus: EventBus
  
  constructor(eventBus: EventBus) {
    this.eventBus = eventBus
  }
  
  async transitionState(appId: string, newState: AppState, data?: any): Promise<void> {
    const currentState = this.appStates.get(appId) || AppState.INSTALLED
    
    // éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
    if (!this.isValidTransition(currentState, newState)) {
      throw new Error(`Invalid state transition: ${currentState} -> ${newState}`)
    }
    
    // æ‰§è¡ŒçŠ¶æ€è½¬æ¢å‰çš„é’©å­
    await this.executeHooks(appId, 'before', newState, data)
    
    // æ›´æ–°çŠ¶æ€
    const previousState = currentState
    this.appStates.set(appId, newState)
    
    // å‘å¸ƒçŠ¶æ€å˜æ›´äº‹ä»¶
    const event: AppLifecycleEvent = {
      appId,
      state: newState,
      previousState,
      timestamp: Date.now(),
      data
    }
    
    this.eventBus.emit('app:state-changed', event)
    
    // æ‰§è¡ŒçŠ¶æ€è½¬æ¢åçš„é’©å­
    await this.executeHooks(appId, 'after', newState, data)
    
    // å¤„ç†ç‰¹æ®ŠçŠ¶æ€
    await this.handleSpecialStates(appId, newState, data)
  }
  
  private isValidTransition(from: AppState, to: AppState): boolean {
    const validTransitions: Record<AppState, AppState[]> = {
      [AppState.INSTALLING]: [AppState.INSTALLED, AppState.ERROR],
      [AppState.INSTALLED]: [AppState.STARTING, AppState.UPDATING, AppState.UNINSTALLING],
      [AppState.STARTING]: [AppState.RUNNING, AppState.ERROR],
      [AppState.RUNNING]: [AppState.PAUSED, AppState.STOPPING, AppState.ERROR],
      [AppState.PAUSED]: [AppState.RUNNING, AppState.STOPPING],
      [AppState.STOPPING]: [AppState.STOPPED, AppState.ERROR],
      [AppState.STOPPED]: [AppState.STARTING, AppState.UNINSTALLING],
      [AppState.UPDATING]: [AppState.INSTALLED, AppState.ERROR],
      [AppState.UNINSTALLING]: [AppState.INSTALLED, AppState.ERROR], // å¸è½½å¤±è´¥å›åˆ°å·²å®‰è£…çŠ¶æ€
      [AppState.ERROR]: [AppState.STARTING, AppState.STOPPING, AppState.UNINSTALLING]
    }
    
    return validTransitions[from]?.includes(to) || false
  }
  
  private async executeHooks(appId: string, phase: 'before' | 'after', state: AppState, data?: any): Promise<void> {
    const hooks = this.lifecycleHooks.get(`${appId}:${phase}:${state}`) || []
    
    for (const hook of hooks) {
      try {
        await hook.execute(appId, state, data)
      } catch (error) {
        console.error(`Lifecycle hook failed for ${appId}:${phase}:${state}:`, error)
        
        if (hook.critical) {
          throw error
        }
      }
    }
  }
  
  private async handleSpecialStates(appId: string, state: AppState, data?: any): Promise<void> {
    switch (state) {
      case AppState.RUNNING:
        await this.handleAppStarted(appId, data)
        break
        
      case AppState.PAUSED:
        await this.handleAppPaused(appId, data)
        break
        
      case AppState.STOPPED:
        await this.handleAppStopped(appId, data)
        break
        
      case AppState.ERROR:
        await this.handleAppError(appId, data)
        break
    }
  }
  
  private async handleAppStarted(appId: string, data?: any): Promise<void> {
    // è®°å½•å¯åŠ¨æ—¶é—´
    await this.recordMetric(appId, 'startup_time', data?.startupTime)
    
    // åˆå§‹åŒ–åº”ç”¨ç›‘æ§
    await this.startAppMonitoring(appId)
    
    // å‘é€å¯åŠ¨é€šçŸ¥
    this.eventBus.emit('app:started', { appId, data })
  }
  
  private async handleAppPaused(appId: string, data?: any): Promise<void> {
    // æš‚åœåº”ç”¨ç›‘æ§
    await this.pauseAppMonitoring(appId)
    
    // é‡Šæ”¾éƒ¨åˆ†èµ„æº
    await this.releaseNonEssentialResources(appId)
    
    this.eventBus.emit('app:paused', { appId, data })
  }
  
  private async handleAppStopped(appId: string, data?: any): Promise<void> {
    // åœæ­¢åº”ç”¨ç›‘æ§
    await this.stopAppMonitoring(appId)
    
    // æ¸…ç†åº”ç”¨èµ„æº
    await this.cleanupAppResources(appId)
    
    // ä¿å­˜åº”ç”¨çŠ¶æ€
    await this.saveAppState(appId)
    
    this.eventBus.emit('app:stopped', { appId, data })
  }
  
  private async handleAppError(appId: string, data?: any): Promise<void> {
    // è®°å½•é”™è¯¯ä¿¡æ¯
    await this.recordError(appId, data?.error)
    
    // å°è¯•è‡ªåŠ¨æ¢å¤
    if (data?.autoRecover !== false) {
      await this.attemptAutoRecovery(appId, data?.error)
    }
    
    this.eventBus.emit('app:error', { appId, error: data?.error })
  }
}
```

### åº”ç”¨ç›‘æ§

```typescript
class AppMonitor {
  private monitors: Map<string, AppMonitorInstance> = new Map()
  private metrics: Map<string, AppMetrics> = new Map()
  
  async startMonitoring(appId: string): Promise<void> {
    if (this.monitors.has(appId)) {
      return // å·²åœ¨ç›‘æ§ä¸­
    }
    
    const monitor = new AppMonitorInstance(appId)
    
    // ç›‘æ§æ€§èƒ½æŒ‡æ ‡
    monitor.trackPerformance({
      cpu: true,
      memory: true,
      network: true,
      dom: true
    })
    
    // ç›‘æ§é”™è¯¯
    monitor.trackErrors({
      javascript: true,
      network: true,
      resource: true
    })
    
    // ç›‘æ§ç”¨æˆ·äº¤äº’
    monitor.trackUserInteraction({
      clicks: true,
      scrolls: true,
      inputs: true
    })
    
    // è®¾ç½®ç›‘æ§å›è°ƒ
    monitor.onMetricsUpdate((metrics: AppMetrics) => {
      this.updateMetrics(appId, metrics)
    })
    
    monitor.onThresholdExceeded((metric: string, value: number, threshold: number) => {
      this.handleThresholdExceeded(appId, metric, value, threshold)
    })
    
    await monitor.start()
    this.monitors.set(appId, monitor)
  }
  
  async stopMonitoring(appId: string): Promise<void> {
    const monitor = this.monitors.get(appId)
    if (monitor) {
      await monitor.stop()
      this.monitors.delete(appId)
    }
  }
  
  private updateMetrics(appId: string, metrics: AppMetrics): void {
    this.metrics.set(appId, metrics)
    
    // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
    this.checkPerformanceThresholds(appId, metrics)
    
    // è®°å½•å†å²æ•°æ®
    this.recordHistoricalMetrics(appId, metrics)
  }
  
  private checkPerformanceThresholds(appId: string, metrics: AppMetrics): void {
    const thresholds = this.getPerformanceThresholds(appId)
    
    if (metrics.memory.heapUsed > thresholds.maxMemory) {
      this.handleThresholdExceeded(appId, 'memory', metrics.memory.heapUsed, thresholds.maxMemory)
    }
    
    if (metrics.cpu.usage > thresholds.maxCPU) {
      this.handleThresholdExceeded(appId, 'cpu', metrics.cpu.usage, thresholds.maxCPU)
    }
    
    if (metrics.dom.nodeCount > thresholds.maxDOMNodes) {
      this.handleThresholdExceeded(appId, 'dom', metrics.dom.nodeCount, thresholds.maxDOMNodes)
    }
  }
  
  private handleThresholdExceeded(appId: string, metric: string, value: number, threshold: number): void {
    console.warn(`App ${appId} exceeded ${metric} threshold: ${value}/${threshold}`)
    
    // å‘é€è­¦å‘Šäº‹ä»¶
    this.eventBus.emit('app:performance-warning', {
      appId,
      metric,
      value,
      threshold
    })
    
    // æ ¹æ®ä¸¥é‡ç¨‹åº¦é‡‡å–è¡ŒåŠ¨
    const severity = this.calculateSeverity(value, threshold)
    
    switch (severity) {
      case 'warning':
        this.sendPerformanceWarning(appId, metric, value, threshold)
        break
        
      case 'critical':
        this.handleCriticalPerformance(appId, metric, value, threshold)
        break
        
      case 'emergency':
        this.emergencyAppTermination(appId, metric, value, threshold)
        break
    }
  }
}
```

## ğŸ’¾ æ•°æ®å­˜å‚¨æ¶æ„

### åˆ†å±‚å­˜å‚¨

```typescript
interface StorageLayer {
  name: string
  priority: number
  capacity: number
  persistence: 'temporary' | 'persistent' | 'permanent'
  encryption: boolean
}

const STORAGE_LAYERS: StorageLayer[] = [
  {
    name: 'memory',
    priority: 1,
    capacity: 50 * 1024 * 1024, // 50MB
    persistence: 'temporary',
    encryption: false
  },
  {
    name: 'indexeddb',
    priority: 2,
    capacity: 500 * 1024 * 1024, // 500MB
    persistence: 'persistent',
    encryption: true
  },
  {
    name: 'filesystem',
    priority: 3,
    capacity: 2 * 1024 * 1024 * 1024, // 2GB
    persistence: 'permanent',
    encryption: true
  }
]

class LayeredStorageManager {
  private layers: Map<string, StorageProvider> = new Map()
  private routingTable: Map<string, string> = new Map()
  
  constructor() {
    this.initializeLayers()
  }
  
  private async initializeLayers(): Promise<void> {
    for (const layerConfig of STORAGE_LAYERS) {
      const provider = this.createStorageProvider(layerConfig)
      await provider.initialize()
      this.layers.set(layerConfig.name, provider)
    }
  }
  
  async store(appId: string, key: string, value: any, options?: StorageOptions): Promise<void> {
    const layerName = this.selectOptimalLayer(appId, key, value, options)
    const provider = this.layers.get(layerName)!
    
    // åŠ å¯†æ•æ„Ÿæ•°æ®
    const processedValue = await this.processValue(value, layerName, options)
    
    await provider.set(`${appId}:${key}`, processedValue)
    
    // æ›´æ–°è·¯ç”±è¡¨
    this.routingTable.set(`${appId}:${key}`, layerName)
    
    // è®°å½•å­˜å‚¨æŒ‡æ ‡
    await this.recordStorageMetrics(appId, layerName, key, value)
  }
  
  async retrieve(appId: string, key: string): Promise<any> {
    const layerName = this.routingTable.get(`${appId}:${key}`)
    if (!layerName) {
      return null
    }
    
    const provider = this.layers.get(layerName)!
    const rawValue = await provider.get(`${appId}:${key}`)
    
    if (rawValue === null) {
      // æ•°æ®å¯èƒ½å·²è¢«æ¸…ç†ï¼Œä»è·¯ç”±è¡¨ä¸­ç§»é™¤
      this.routingTable.delete(`${appId}:${key}`)
      return null
    }
    
    // è§£å¯†å’Œååºåˆ—åŒ–
    return this.processRetrievedValue(rawValue, layerName)
  }
  
  private selectOptimalLayer(appId: string, key: string, value: any, options?: StorageOptions): string {
    const valueSize = this.calculateValueSize(value)
    const requiredPersistence = options?.persistence || 'persistent'
    const requiresEncryption = options?.encrypt || this.isSensitiveData(value)
    
    // æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä½³å­˜å‚¨å±‚
    for (const layer of STORAGE_LAYERS) {
      const provider = this.layers.get(layer.name)!
      
      // æ£€æŸ¥å®¹é‡
      if (valueSize > layer.capacity) {
        continue
      }
      
      // æ£€æŸ¥æŒä¹…æ€§è¦æ±‚
      if (!this.isPersistenceCompatible(requiredPersistence, layer.persistence)) {
        continue
      }
      
      // æ£€æŸ¥åŠ å¯†è¦æ±‚
      if (requiresEncryption && !layer.encryption) {
        continue
      }
      
      // æ£€æŸ¥å¯ç”¨ç©ºé—´
      const availableSpace = await provider.getAvailableSpace()
      if (valueSize > availableSpace) {
        continue
      }
      
      return layer.name
    }
    
    throw new Error('No suitable storage layer found')
  }
  
  private async processValue(value: any, layerName: string, options?: StorageOptions): Promise<any> {
    let processed = value
    
    // åºåˆ—åŒ–
    if (typeof processed !== 'string') {
      processed = JSON.stringify(processed)
    }
    
    // å‹ç¼©å¤§æ•°æ®
    if (processed.length > 1024 * 1024) { // 1MB
      processed = await this.compress(processed)
    }
    
    // åŠ å¯†
    const layer = STORAGE_LAYERS.find(l => l.name === layerName)!
    if (layer.encryption || options?.encrypt) {
      processed = await this.encrypt(processed)
    }
    
    return processed
  }
}
```

### æ•°æ®åŒæ­¥

```typescript
class DataSyncManager {
  private syncQueues: Map<string, SyncQueue> = new Map()
  private conflictResolvers: Map<string, ConflictResolver> = new Map()
  
  async enableSync(appId: string, config: SyncConfig): Promise<void> {
    const syncQueue = new SyncQueue(appId, config)
    
    // ç›‘å¬æ•°æ®å˜æ›´
    syncQueue.onDataChange(async (change: DataChange) => {
      await this.queueSync(appId, change)
    })
    
    // å¤„ç†åŒæ­¥å†²çª
    syncQueue.onConflict(async (conflict: SyncConflict) => {
      await this.resolveConflict(appId, conflict)
    })
    
    this.syncQueues.set(appId, syncQueue)
    
    // å¯åŠ¨åˆå§‹åŒæ­¥
    await this.performInitialSync(appId)
  }
  
  private async queueSync(appId: string, change: DataChange): Promise<void> {
    const queue = this.syncQueues.get(appId)!
    
    // æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
    queue.enqueue({
      id: generateId(),
      appId,
      change,
      timestamp: Date.now(),
      retryCount: 0
    })
    
    // è§¦å‘åŒæ­¥å¤„ç†
    this.processSyncQueue(appId)
  }
  
  private async processSyncQueue(appId: string): Promise<void> {
    const queue = this.syncQueues.get(appId)!
    
    while (!queue.isEmpty()) {
      const syncItem = queue.dequeue()
      
      try {
        await this.syncToRemote(syncItem)
        
        // åŒæ­¥æˆåŠŸï¼Œè®°å½•æ—¥å¿—
        await this.recordSyncSuccess(syncItem)
        
      } catch (error) {
        // åŒæ­¥å¤±è´¥ï¼Œå¤„ç†é‡è¯•
        await this.handleSyncFailure(syncItem, error)
      }
    }
  }
  
  private async syncToRemote(syncItem: SyncItem): Promise<void> {
    const config = this.getSyncConfig(syncItem.appId)
    
    if (!config.remoteEndpoint) {
      return // æ— è¿œç¨‹ç«¯ç‚¹ï¼Œè·³è¿‡åŒæ­¥
    }
    
    const payload = {
      appId: syncItem.appId,
      change: syncItem.change,
      timestamp: syncItem.timestamp,
      checksum: this.calculateChecksum(syncItem.change)
    }
    
    const response = await fetch(config.remoteEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${config.authToken}`
      },
      body: JSON.stringify(payload)
    })
    
    if (!response.ok) {
      throw new Error(`Sync failed: ${response.statusText}`)
    }
    
    const result = await response.json()
    
    // å¤„ç†æœåŠ¡å™¨è¿”å›çš„å†²çª
    if (result.conflict) {
      await this.handleServerConflict(syncItem, result.conflict)
    }
  }
  
  private async resolveConflict(appId: string, conflict: SyncConflict): Promise<void> {
    const resolver = this.conflictResolvers.get(appId) || this.getDefaultResolver()
    
    const resolution = await resolver.resolve(conflict)
    
    switch (resolution.strategy) {
      case 'local-wins':
        await this.applyLocalVersion(conflict)
        break
        
      case 'remote-wins':
        await this.applyRemoteVersion(conflict)
        break
        
      case 'merge':
        await this.mergeVersions(conflict, resolution.mergedData)
        break
        
      case 'user-choice':
        await this.requestUserResolution(conflict)
        break
    }
  }
}
```

## ğŸ”— é€šä¿¡æœºåˆ¶

### äº‹ä»¶æ€»çº¿

```typescript
class SystemEventBus {
  private listeners: Map<string, EventListener[]> = new Map()
  private middlewares: EventMiddleware[] = []
  private eventHistory: EventRecord[] = []
  
  on(event: string, listener: EventListener, options?: EventOptions): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, [])
    }
    
    const wrappedListener = this.wrapListener(listener, options)
    this.listeners.get(event)!.push(wrappedListener)
  }
  
  emit(event: string, data?: any, source?: string): void {
    const eventRecord: EventRecord = {
      id: generateId(),
      event,
      data,
      source: source || 'system',
      timestamp: Date.now()
    }
    
    // è®°å½•äº‹ä»¶å†å²
    this.eventHistory.push(eventRecord)
    this.trimEventHistory()
    
    // åº”ç”¨ä¸­é—´ä»¶
    const processedEvent = this.applyMiddlewares(eventRecord)
    
    if (processedEvent.cancelled) {
      return
    }
    
    // åˆ†å‘äº‹ä»¶
    const listeners = this.listeners.get(event) || []
    
    for (const listener of listeners) {
      try {
        listener(processedEvent.data, processedEvent)
      } catch (error) {
        console.error(`Event listener error for ${event}:`, error)
        
        // å‘é€é”™è¯¯äº‹ä»¶
        this.emit('system:event-error', {
          originalEvent: event,
          error: error.message,
          listener: listener.name
        })
      }
    }
  }
  
  private wrapListener(listener: EventListener, options?: EventOptions): EventListener {
    return (data: any, event: EventRecord) => {
      // æ£€æŸ¥æƒé™
      if (options?.requiredPermission) {
        const hasPermission = this.checkEventPermission(event.source, options.requiredPermission)
        if (!hasPermission) {
          console.warn(`Permission denied for event ${event.event} from ${event.source}`)
          return
        }
      }
      
      // æ£€æŸ¥é¢‘ç‡é™åˆ¶
      if (options?.rateLimit) {
        const allowed = this.checkRateLimit(event.source, event.event, options.rateLimit)
        if (!allowed) {
          console.warn(`Rate limit exceeded for event ${event.event} from ${event.source}`)
          return
        }
      }
      
      // æ‰§è¡Œç›‘å¬å™¨
      listener(data, event)
    }
  }
  
  private applyMiddlewares(event: EventRecord): ProcessedEvent {
    let processedEvent: ProcessedEvent = {
      ...event,
      cancelled: false,
      modified: false
    }
    
    for (const middleware of this.middlewares) {
      processedEvent = middleware.process(processedEvent)
      
      if (processedEvent.cancelled) {
        break
      }
    }
    
    return processedEvent
  }
}
```

### åº”ç”¨é—´é€šä¿¡

```typescript
class InterAppCommunication {
  private channels: Map<string, CommunicationChannel> = new Map()
  private messageQueue: Map<string, Message[]> = new Map()
  
  async createChannel(fromAppId: string, toAppId: string, options?: ChannelOptions): Promise<string> {
    // æ£€æŸ¥æƒé™
    await this.checkCommunicationPermission(fromAppId, toAppId)
    
    const channelId = generateId()
    const channel = new CommunicationChannel({
      id: channelId,
      fromAppId,
      toAppId,
      options: options || {}
    })