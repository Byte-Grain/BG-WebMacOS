# 事件系统中期优化使用指南

## 概述

本文档介绍了 macOS Web 项目事件系统中期优化的新功能和使用方法。中期优化在短期优化的基础上，增加了企业级功能，包括事件中间件、路由系统、生命周期管理、调试工具和统一管理器。

## 新增功能

### 1. 事件中间件系统 (`useEventMiddleware`)

事件中间件允许在事件处理过程中插入自定义逻辑，支持日志记录、验证、缓存、限流等功能。

#### 基本使用

```typescript
import { useEventMiddleware, useBuiltInMiddlewares } from '@/composables'

const middleware = useEventMiddleware()
const builtIn = useBuiltInMiddlewares()

// 注册内置中间件
middleware.register('logging', builtIn.createLoggingMiddleware())
middleware.register('validation', builtIn.createValidationMiddleware())
middleware.register('performance', builtIn.createPerformanceMiddleware())

// 注册自定义中间件
middleware.register('custom', async (eventName, eventData, context, next) => {
  console.log(`Processing event: ${eventName}`)
  const result = await next()
  console.log(`Event processed: ${eventName}`)
  return result
})

// 执行中间件链
const result = await middleware.execute('app:startup', { version: '1.0.0' })
```

#### 内置中间件

- **日志中间件**: 记录事件执行日志
- **验证中间件**: 验证事件数据格式
- **缓存中间件**: 缓存事件结果
- **限流中间件**: 控制事件执行频率
- **性能中间件**: 监控事件执行性能
- **安全中间件**: 检查事件安全性
- **错误处理中间件**: 统一错误处理
- **调试中间件**: 开发环境调试支持

### 2. 事件路由系统 (`useEventRouter`)

事件路由系统支持将事件分发到不同的目标，支持多种分发策略和负载均衡。

#### 基本使用

```typescript
import { useEventRouter } from '@/composables'

const router = useEventRouter()

// 注册路由
router.registerRoute('user:*', {
  pattern: 'user:*',
  strategy: 'all', // 分发到所有匹配的目标
  targets: [
    {
      id: 'user-service',
      handler: async (eventName, eventData) => {
        // 处理用户相关事件
        console.log('User service handling:', eventName)
      },
      weight: 1,
      enabled: true
    },
    {
      id: 'audit-service',
      handler: async (eventName, eventData) => {
        // 审计日志
        console.log('Audit service logging:', eventName)
      },
      weight: 1,
      enabled: true
    }
  ]
})

// 分发事件
const result = await router.distribute('user:login', { userId: '123' })
```

#### 分发策略

- **all**: 分发到所有匹配的目标
- **first**: 分发到第一个匹配的目标
- **random**: 随机选择一个目标
- **round-robin**: 轮询分发
- **weighted**: 基于权重分发
- **load-balanced**: 基于负载均衡分发

### 3. 事件生命周期管理 (`useEventLifecycle`)

事件生命周期管理提供事件状态跟踪、依赖管理、持久化和恢复功能。

#### 基本使用

```typescript
import { useEventLifecycle } from '@/composables'

const lifecycle = useEventLifecycle()

// 开始事件
const eventId = lifecycle.startEvent('app:startup', { version: '1.0.0' })

// 添加检查点
lifecycle.addCheckpoint(eventId, 'config-loaded', { configPath: '/config.json' })
lifecycle.addCheckpoint(eventId, 'services-initialized', { serviceCount: 5 })

// 设置事件依赖
lifecycle.addDependency(eventId, 'config:loaded')
lifecycle.addDependency(eventId, 'database:connected')

// 完成事件
lifecycle.completeEvent(eventId, { success: true })

// 查询事件状态
const record = lifecycle.getEventRecord(eventId)
console.log('Event status:', record?.status)
console.log('Event phases:', record?.phases)
```

#### 事件状态

- **pending**: 等待开始
- **running**: 正在执行
- **completed**: 已完成
- **failed**: 执行失败
- **timeout**: 执行超时
- **cancelled**: 已取消

### 4. 事件调试工具 (`useEventDebugger`)

事件调试工具提供实时监控、性能分析、事件流可视化和调试日志功能。

#### 基本使用

```typescript
import { useEventDebugger } from '@/composables'

const debugger = useEventDebugger()

// 配置调试器
debugger.config.value = {
  enabled: true,
  level: 'debug',
  maxRecords: 10000,
  captureStack: true,
  trackPerformance: true,
  visualizeFlow: true,
  realTimeMonitoring: true
}

// 记录调试信息
debugger.logEventTriggered('user:login', { userId: '123' })
debugger.logEventCompleted('user:login', 150, { success: true })

// 开始事件流跟踪
const flowNode = debugger.startEventFlow('event-123', 'user:login')
const middlewareNode = debugger.addFlowNode('event-123', 'middleware', 'validation')
debugger.updateFlowNode(middlewareNode, 'completed')

// 获取性能指标
console.log('Performance metrics:', debugger.performanceMetrics)

// 导出调试数据
const exportData = debugger.exportData({
  format: 'json',
  includeMetadata: true,
  includeStack: true
})
```

#### 调试级别

- **verbose**: 详细信息
- **debug**: 调试信息
- **info**: 一般信息
- **warn**: 警告信息
- **error**: 错误信息

### 5. 企业级事件管理器 (`useEnterpriseEventManager`)

企业级事件管理器整合了所有事件系统组件，提供统一的管理接口和企业级功能。

#### 基本使用

```typescript
import { useEnterpriseEventManager } from '@/composables'

// 创建管理器实例
const eventManager = useEnterpriseEventManager({
  enableMiddleware: true,
  enableRouting: true,
  enableLifecycle: true,
  enableDebugging: true,
  
  middlewareConfig: {
    enableLogging: true,
    enableValidation: true,
    enablePerformanceMonitoring: true,
    enableSecurity: true
  },
  
  performanceConfig: {
    enableMetrics: true,
    alertThresholds: {
      maxEventTime: 1000,
      maxMemoryUsage: 100 * 1024 * 1024,
      maxErrorRate: 5
    }
  },
  
  securityConfig: {
    enableEventValidation: true,
    maxEventSize: 1024 * 1024,
    blockedEventTypes: ['dangerous:event']
  }
})

// 监控系统状态
console.log('System status:', eventManager.systemStatus)
console.log('Active alerts:', eventManager.activeAlerts)

// 生成性能报告
const report = eventManager.generatePerformanceReport(3600000) // 1小时
console.log('Performance report:', report)

// 处理告警
eventManager.activeAlerts.value.forEach(alert => {
  if (alert.level === 'critical') {
    console.error('Critical alert:', alert.message)
    // 处理关键告警
    eventManager.resolveAlert(alert.id)
  }
})
```

## 实际应用示例

### 1. 用户登录流程优化

```typescript
import { useEnterpriseEventManager } from '@/composables'

const eventManager = useEnterpriseEventManager()

// 注册用户登录路由
eventManager.router.registerRoute('user:login', {
  pattern: 'user:login',
  strategy: 'all',
  targets: [
    {
      id: 'auth-service',
      handler: async (eventName, eventData) => {
        // 验证用户凭据
        const { username, password } = eventData
        return await authenticateUser(username, password)
      }
    },
    {
      id: 'audit-service',
      handler: async (eventName, eventData) => {
        // 记录登录尝试
        await logLoginAttempt(eventData.username)
      }
    },
    {
      id: 'analytics-service',
      handler: async (eventName, eventData) => {
        // 统计分析
        await trackUserLogin(eventData.username)
      }
    }
  ]
})

// 触发登录事件
try {
  const result = await eventManager.eventBus.emit('user:login', {
    username: 'john@example.com',
    password: 'password123',
    timestamp: Date.now()
  })
  
  console.log('Login successful:', result)
} catch (error) {
  console.error('Login failed:', error)
}
```

### 2. 应用启动流程管理

```typescript
import { useEventLifecycle, useEventDebugger } from '@/composables'

const lifecycle = useEventLifecycle()
const debugger = useEventDebugger()

// 应用启动流程
async function startApplication() {
  const eventId = lifecycle.startEvent('app:startup', { version: '1.0.0' })
  
  try {
    // 阶段1: 加载配置
    lifecycle.updatePhase(eventId, 'loading-config')
    await loadConfiguration()
    lifecycle.addCheckpoint(eventId, 'config-loaded')
    
    // 阶段2: 初始化服务
    lifecycle.updatePhase(eventId, 'initializing-services')
    await initializeServices()
    lifecycle.addCheckpoint(eventId, 'services-initialized')
    
    // 阶段3: 连接数据库
    lifecycle.updatePhase(eventId, 'connecting-database')
    await connectDatabase()
    lifecycle.addCheckpoint(eventId, 'database-connected')
    
    // 阶段4: 启动完成
    lifecycle.updatePhase(eventId, 'startup-complete')
    lifecycle.completeEvent(eventId, { success: true, duration: Date.now() - lifecycle.getEventRecord(eventId)!.startTime })
    
    debugger.logEventCompleted('app:startup', Date.now() - lifecycle.getEventRecord(eventId)!.startTime)
    
  } catch (error) {
    lifecycle.failEvent(eventId, error as Error)
    debugger.logEventFailed('app:startup', error as Error)
    throw error
  }
}
```

### 3. 性能监控和告警

```typescript
import { useEnterpriseEventManager } from '@/composables'

const eventManager = useEnterpriseEventManager({
  performanceConfig: {
    enableMetrics: true,
    alertThresholds: {
      maxEventTime: 500,      // 500ms
      maxMemoryUsage: 50 * 1024 * 1024, // 50MB
      maxErrorRate: 2         // 2%
    }
  }
})

// 监听告警
watch(eventManager.activeAlerts, (alerts) => {
  alerts.forEach(alert => {
    switch (alert.type) {
      case 'performance':
        console.warn('Performance issue detected:', alert.message)
        // 可以触发性能优化措施
        break
        
      case 'memory':
        console.warn('Memory usage high:', alert.message)
        // 可以触发垃圾回收或内存清理
        break
        
      case 'error':
        console.error('Error rate high:', alert.message)
        // 可以触发错误恢复机制
        break
    }
  })
})

// 定期生成性能报告
setInterval(() => {
  const report = eventManager.generatePerformanceReport(300000) // 5分钟
  
  if (report.errorRate > 5) {
    console.error('High error rate detected:', report.errorRate + '%')
  }
  
  if (report.averageEventTime > 1000) {
    console.warn('Slow event processing detected:', report.averageEventTime + 'ms')
  }
}, 300000)
```

## 最佳实践

### 1. 中间件使用

- 按执行顺序注册中间件
- 使用内置中间件覆盖常见需求
- 自定义中间件保持轻量和专一
- 避免在中间件中执行耗时操作

### 2. 路由配置

- 使用通配符模式提高路由匹配效率
- 根据业务需求选择合适的分发策略
- 为关键服务设置合理的权重
- 定期检查和清理无效的路由目标

### 3. 生命周期管理

- 为长时间运行的事件设置合理的超时时间
- 使用检查点记录关键执行节点
- 合理设置事件依赖关系
- 定期清理过期的事件记录

### 4. 调试和监控

- 在生产环境中适当降低调试级别
- 定期导出和分析调试数据
- 设置合理的性能告警阈值
- 使用事件流可视化排查复杂问题

### 5. 企业级管理

- 根据应用规模调整配置参数
- 建立告警响应机制
- 定期生成和分析性能报告
- 实施安全策略和访问控制

## 迁移指南

### 从短期优化迁移

1. **保持向后兼容**: 现有的事件系统代码无需修改
2. **渐进式采用**: 可以逐步启用新功能
3. **配置调整**: 根据需要调整企业级管理器配置
4. **监控验证**: 启用调试和监控功能验证迁移效果

### 迁移步骤

```typescript
// 1. 替换事件总线导入
// 旧代码
import { useEventBus } from '@/composables'
const eventBus = useEventBus()

// 新代码
import { useEnterpriseEventManager } from '@/composables'
const eventManager = useEnterpriseEventManager()
const eventBus = eventManager.eventBus // 保持API兼容

// 2. 启用需要的功能
eventManager.config.value.enableMiddleware = true
eventManager.config.value.enableDebugging = true

// 3. 添加监控和告警
watch(eventManager.systemStatus, (status) => {
  if (!status.isHealthy) {
    console.warn('System health issue detected')
  }
})
```

## 性能考虑

### 1. 内存使用

- 调试记录会占用内存，生产环境建议限制记录数量
- 事件流数据在事件完成后会自动清理
- 定期清理过期的生命周期记录

### 2. 执行性能

- 中间件会增加事件处理时间，选择必要的中间件
- 路由匹配使用高效的模式匹配算法
- 调试功能在生产环境可以禁用或降级

### 3. 网络开销

- 分布式路由可能涉及网络通信
- 持久化功能可能需要数据库操作
- 监控数据传输需要考虑带宽限制

## 故障排除

### 常见问题

1. **中间件执行失败**
   - 检查中间件注册顺序
   - 验证中间件函数签名
   - 查看调试日志获取详细错误信息

2. **路由匹配失败**
   - 验证路由模式语法
   - 检查目标处理器是否正确注册
   - 确认目标处理器状态为启用

3. **性能问题**
   - 检查中间件执行时间
   - 分析事件处理链路
   - 查看性能监控数据

4. **内存泄漏**
   - 检查调试记录清理配置
   - 验证事件监听器是否正确移除
   - 监控内存使用趋势

### 调试技巧

```typescript
// 启用详细调试
eventManager.debugger.config.value.level = 'verbose'

// 导出调试数据进行分析
const debugData = eventManager.debugger.exportData({
  format: 'json',
  includeMetadata: true,
  timeRange: {
    start: Date.now() - 3600000, // 最近1小时
    end: Date.now()
  }
})

// 查看事件流
const flowData = eventManager.debugger.getEventFlowData()
console.log('Event flows:', flowData)

// 分析性能指标
const metrics = eventManager.performanceMetrics
console.log('Performance metrics:', metrics)
```

## 总结

事件系统中期优化为 macOS Web 项目提供了企业级的事件处理能力，包括：

- **中间件系统**: 提供可插拔的事件处理逻辑
- **路由系统**: 支持灵活的事件分发策略
- **生命周期管理**: 完整的事件状态跟踪
- **调试工具**: 强大的开发和运维支持
- **企业级管理**: 统一的配置和监控

这些功能大大提升了事件系统的可维护性、可扩展性和可观测性，为项目的长期发展奠定了坚实的基础。

通过合理配置和使用这些新功能，开发团队可以：

- 更好地理解和调试事件流
- 实现更复杂的业务逻辑
- 提高系统的可靠性和性能
- 简化运维和监控工作

建议在实际项目中根据具体需求逐步采用这些功能，并根据使用情况持续优化配置。